document.addEventListener("DOMContentLoaded", function () {

  function shuffle(arr){
    for(let i = arr.length - 1; i > 0; i--){
      let j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function normalize(s){
    return (s || "").trim().toLowerCase();
  }

  function decodeLastToken(token){
    return token.replace(/^last__/, "").replace(/_/g, " ");
  }

  // Only items explicitly marked with mc_button_rand are processed
  document.querySelectorAll(".mc_button_rand").forEach(function(item){

    // formr usually renders button choices inside a .btn-group
    let group = item.querySelector(".btn-group");
    if(!group) return;

    // Candidate option nodes (formr often uses <label class="btn ..."> or <button class="btn ...">)
    let options = Array.from(group.children).filter(function(el){
      if (!el.classList || !el.classList.contains("btn")) return false;
      // keep only nodes that look like actual options
      return el.querySelector("input[type='radio'], input[type='checkbox']") || el.matches("button");
    });

    if(options.length < 2) return;

    // Read keep-last rules from class list
    let keepLastNeedles = Array.from(item.classList)
      .filter(c => c.indexOf("last__") === 0)
      .map(decodeLastToken)
      .map(normalize);

    let fixed = [];
    let shuffleThese = [];

    options.forEach(function(opt){
      let text = normalize(opt.innerText);
      let matchedIndex = keepLastNeedles.findIndex(function(k){
        return k && text.indexOf(k) !== -1;
      });

      if(matchedIndex >= 0){
        fixed.push({ node: opt, idx: matchedIndex });
      } else {
        shuffleThese.push(opt);
      }
    });

    shuffle(shuffleThese);

    fixed.sort(function(a,b){
      return a.idx - b.idx;
    });

    // Re-append in desired order
    shuffleThese.forEach(function(opt){ group.appendChild(opt); });
    fixed.forEach(function(x){ group.appendChild(x.node); });

  });

});
